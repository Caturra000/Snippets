转载：[cppweeklynews/posts/184.md](https://github.com/wanghenshui/cppweeklynews/blob/dev/posts/184.md)

### [最佳指针标记 tag pointer方法总结](https://coredumped.dev/2024/09/09/what-is-the-best-pointer-tagging-method/)

什么是指针标记？tag pointer

指针标记是一种将元数据编码到指针中的技术，使得指针除了存储地址外还能携带额外信息。

文章分析了以下五种标记指针的方法：

- 低位标记：利用指针通常按机器字对齐，在64位平台上指针底部有3个总是为0的比特位。这些可以用作标记而不影响指针本身。
- 低字节标记：利用指针顶部和底部的未使用空间，将值上移一个字节，用底字节作为标记。
- 高字节标记：类似于低字节，但标记存储在字的顶部而非底部。这允许利用ARM的Top Byte Ignore (TBI)功能。
- 高位标记：也利用指针底部的对齐位，但将标记存储在顶部。
- NaN标记：通常用于浮点数为主要数字类型的语言，利用IEEE浮点数中表示NaN的未使用值来编码指针。

基准测试还包括了"胖指针"作为基线，用两个字来存储标记和指针。


基准测试主要包含两种类型：仅检查标记(Check tag)和获取数据(Get data)。测试在ARM M1 MacBook和Intel x86环境中进行。

#### 标记0的测试

对齐位标记表现最好，因为编译器可以利用零值进行多种优化,特别是可以使用单一指令同时掩码和比较

由于标记为0，指针可以不需额外指令就被解引用

#### 标记1-7的测试

一旦不使用标记零，各对齐标记方法的效率基本相同,不能使用单指令完成标记检查，需要先进行与操作再比较

解引用前需要掩码去除标记，增加额外指令

#### 架构差异

在x86上，低字节标记比其他方法快得多,这是因为x86指令集可以通过单独的寄存器直接访问64位寄存器的低字节
在ARM上，访问低字节只能通过掩码实现

#### 标记检查性能

高位标记方案在纯粹的标记检查中优于低位方案,优化器能够向量化这个操作，同时检查多个高位标记

标记版本显著快于基线版本,编译器能够自动向量化对连续范围标记的检查

#### 函数调用影响

一旦参数数量超过特定大小，程序必须开始向栈溢出参数, 由于非标记值的大小是标记值的两倍，它们会更早达到这个条件

在批量操作中，更大的参数大小会导致相对于标记值的速度下降

#### 标记消除

在解释器中，有时会标记指针后立即解标记, 希望编译器能够消除标记/解标记操作

只有基线方法能完全消除标记, 通过提示，编译器能够消除几乎所有标记操作，除了高字节标记

#### 浮点数考虑

对于浮点数操作，NaN标记的优势在于不需要解引用指针获取浮点值。这种优势大小取决于缓存情况：

- 如果浮点值在缓存中，访问速度差异不大
- 如果不在缓存中，获取可能需要数百个周期

对于大量使用浮点数的数据结构，NaN标记总是最优选择

#### 结论

内存通常是瓶颈，而非CPU指令：节省1-2条指令影响有限，单个缓存未命中可能导致CPU等待数百个周期

一般情况下性能相似：大多数方案都需要1条指令获取标记，1条指令解标记指针

标记数量差异：对齐标记只支持8个标记（64位机器上），而使用整个字节可获得256个标记

可移植性考虑：可能无法总是假设指针的高位未使用，对齐标记在几乎任何架构上都可使用

最终，没有一种"最佳"的指针标记方案，选择取决于具体需求、平台和优化重点。真实工程中的答案通常是"视情况而定"。

----------

批注：了解一下 Intel LAM 对高位标记的影响。
