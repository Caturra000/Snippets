#include "escape.hpp"

#include <iostream>
#include <string>
#include <vector>
#include <cstring>
#include <random>

// ═══════════════════════════════════════════════════════════════════
// 标量参考实现（用于对比验证）
// ═══════════════════════════════════════════════════════════════════
size_t escape_scalar(std::string_view src, std::span<char> dst) {
    size_t len = 0;
    for (char c : src) {
        if (c == '"' || c == '\\') {
            dst[len++] = '\\';
        }
        dst[len++] = c;
    }
    return len;
}

// ═══════════════════════════════════════════════════════════════════
// 测试框架
// ═══════════════════════════════════════════════════════════════════
struct TestCase {
    std::string name;
    std::string input;
};

bool run_test(const TestCase& tc) {
    std::vector<char> dst_simd(tc.input.size() * 2 + 64);
    std::vector<char> dst_scalar(tc.input.size() * 2 + 64);
    
    // 调用两个实现
    size_t len_simd = escape(tc.input, std::span{dst_simd});
    size_t len_scalar = escape_scalar(tc.input, std::span{dst_scalar});
    
    // 比较长度
    if (len_simd != len_scalar) {
        std::cout << "❌ [" << tc.name << "] 长度不匹配!\n";
        std::cout << "   输入:  \"" << tc.input << "\" (" << tc.input.size() << " bytes)\n";
        std::cout << "   SIMD:   " << len_simd << " bytes\n";
        std::cout << "   Scalar: " << len_scalar << " bytes\n";
        return false;
    }
    
    // 比较内容
    if (std::memcmp(dst_simd.data(), dst_scalar.data(), len_scalar) != 0) {
        std::cout << "❌ [" << tc.name << "] 内容不匹配!\n";
        std::cout << "   输入:  \"" << tc.input << "\"\n";
        std::cout << "   SIMD:   \"" << std::string_view(dst_simd.data(), len_simd) << "\"\n";
        std::cout << "   Scalar: \"" << std::string_view(dst_scalar.data(), len_scalar) << "\"\n";
        return false;
    }
    
    std::cout << "✅ [" << tc.name << "]\n";
    return true;
}

int main() {
    std::cout << "═══════════════════════════════════════════════════════\n";
    std::cout << "  Escape 函数正确性验证\n";
    std::cout << "═══════════════════════════════════════════════════════\n\n";

    std::vector<TestCase> tests = {
        // ─────────────────────────────────────────────────────
        // 基础测试
        // ─────────────────────────────────────────────────────
        {"空字符串",           ""},
        {"单字符",             "a"},
        {"单引号",             "\""},
        {"单反斜杠",           "\\"},
        
        // ─────────────────────────────────────────────────────
        // 无需转义
        // ─────────────────────────────────────────────────────
        {"普通短字符串",       "Hello World"},
        {"普通长字符串",       "The quick brown fox jumps over the lazy dog"},
        {"恰好32字节",         "12345678901234567890123456789012"},
        {"恰好64字节",         "1234567890123456789012345678901212345678901234567890123456789012"},
        
        // ─────────────────────────────────────────────────────
        // 需要转义
        // ─────────────────────────────────────────────────────
        {"中间有引号",         "Hello \"World\""},
        {"开头有引号",         "\"Hello World"},
        {"结尾有引号",         "Hello World\""},
        {"中间有反斜杠",       "C:\\Users\\test"},
        {"混合转义",           "Say \"Hi\" to C:\\"},
        
        // ─────────────────────────────────────────────────────
        // 全转义
        // ─────────────────────────────────────────────────────
        {"全引号短",           "\"\"\"\""},
        {"全引号8字节",        "\"\"\"\"\"\"\"\""},
        {"全反斜杠8字节",      "\\\\\\\\\\\\\\\\"},
        {"引号反斜杠交替",     "\"\\\"\\\"\\\"\\"},
        
        // ─────────────────────────────────────────────────────
        // 边界条件
        // ─────────────────────────────────────────────────────
        {"7字节无转义",        "1234567"},
        {"8字节无转义",        "12345678"},
        {"9字节无转义",        "123456789"},
        {"15字节无转义",       "123456789012345"},
        {"16字节无转义",       "1234567890123456"},
        {"17字节无转义",       "12345678901234567"},
        {"31字节无转义",       "1234567890123456789012345678901"},
        {"33字节无转义",       "123456789012345678901234567890123"},
        
        // ─────────────────────────────────────────────────────
        // 转义位置边界
        // ─────────────────────────────────────────────────────
        {"位置0转义",          "\"1234567"},
        {"位置7转义",          "1234567\""},
        {"位置8转义",          "12345678\"1234567"},
        {"位置31转义",         "1234567890123456789012345678901\""},
        {"位置32转义",         "12345678901234567890123456789012\""},
    };

    // 添加随机测试
    std::mt19937 rng(42);
    for (int i = 0; i < 20; i++) {
        size_t len = rng() % 200 + 1;
        std::string s;
        s.reserve(len);
        for (size_t j = 0; j < len; j++) {
            int r = rng() % 100;
            if (r < 5)       s += '"';
            else if (r < 10) s += '\\';
            else             s += 'a' + (rng() % 26);
        }
        tests.push_back({"随机测试#" + std::to_string(i + 1), std::move(s)});
    }

    // 运行所有测试
    int passed = 0, failed = 0;
    for (const auto& tc : tests) {
        if (run_test(tc)) {
            passed++;
        } else {
            failed++;
        }
    }

    // 汇总
    std::cout << "\n═══════════════════════════════════════════════════════\n";
    std::cout << "  结果: " << passed << " 通过, " << failed << " 失败\n";
    std::cout << "═══════════════════════════════════════════════════════\n";

    return failed > 0 ? 1 : 0;
}
